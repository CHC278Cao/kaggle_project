
import os
from tqdm import tqdm
import random
import numpy as np
import pandas as pd

import spacy
from spacy.util import minibatch
from spacy.util import compounding


class NerModel(object):
    def __init__(self, output_dir):
        """
            Build NER model to generate prediction
        :param output_dir: Type: str, the directory to save model
        """
        self.output_dir = output_dir

    def generate_data(self, df, sentiment):
        """
            Create training data in ner format
        :param df: Type: DataFrame, train dataframe
        :param sentiment: Type: str, sentiment values("positive", "negative", "neutral")
        :return:
            train data have special format like ((text, {"entities": [[start, end, label]]}))
        """
        train_data = []
        for row in df.itertuples():
            if row.sentiment == sentiment:
                selected_text = row.selected_text
                text = row.text
                start_idx = text.find(selected_text)
                end_idx = start_idx + len(selected_text)
                train_data.append((text, {"entities": [[start_idx, end_idx, "selected_text"]]}))
        return train_data

    def train(self, train_data, sentiment, n_iter, model_dir=None, model=None):
        """
            Train model based on training data
        :param train_data: data is generate from "generate_data" function and to be trained
        :param sentiment: Type: str, including "positive", "negative" and "neutral"
        :param n_iter: Type: int, epochs to be trained
        :param model_dir: Type: str, directory for pretrained model
        :param model: Tyle str, model name
        :return:
            new trained model
        """
        if model is not None:
            if model_dir is None:
                raise ValueError("model path can't be None")
            nlp = spacy.load(model_dir)
            print(f"Loading model {model}")
        else:
            nlp = spacy.blank('en')
            print("Create blank 'en' model")

        # Create the built-in pipeline components and add them to the pipeline
        # nlp.create_pipe works for built-ins that are registered with spaCy
        if "ner" not in nlp.pipe_names:
            ner = nlp.create_pipe("ner")
            nlp.add_pipe(ner, last=True)
        else:
            ner = nlp.get_pipe("ner")

        # add labels
        for _, annotations in train_data:
            for ent in annotations.get("entities"):
                ner.add_label(ent[2])

        # get names of other pipes to disable them during train
        other_pipes = [pipe for pipe in nlp.pipe_names if pipe != 'ner']
        # only train ner and disable other pipes
        with nlp.disable_pipes(*other_pipes):
            if model is None:
                nlp.begin_training()
            else:
                nlp.resume_training()

            for _ in tqdm(range(n_iter)):
                random.shuffle(train_data)
                batches = minibatch(train_data, size=compounding(start=4.0, stop=500.0, compound=1.001))
                losses = {}
                for batch in batches:
                    texts, annotations = zip(*batch)
                    nlp.update(
                        texts,
                        annotations,
                        drop=0.5,
                        losses = losses,
                    )
                print(f"Losses = {losses}")
        self.save_model(nlp, 'st_ner', f"{self.output_dir}/models/model_{sentiment}")

    def predict(self, test_df):
        """
            Get the prediction for test_df
        :param test_df: Type: Dataframe, df to be tested
        :return:
            prediction generated by model
        """
        pos_path = f"{self.output_dir}/models/model_positive"
        neg_path = f"{self.output_dir}/models/model_negative"
        model_pos = self.load_model(pos_path)
        model_neg = self.load_model(neg_path)
        selected_text = []

        for row in test_df.itertuples():
            text = row.text
            if row.sentiment == "neutral" or len(text.split()) <= 2:
                selected_text.append(text)
            elif row.sentiment == "positive":
                selected_text.append(self.predict_entities(text, model_pos))
            else:
                selected_text.append((self.predict_entities(text, model_neg)))
        return selected_text

    def predict_entities(self, text, model):
        """
            Get the prediction for text
        :param text: Type: str, text to be predicted
        :param model: Type: NerModel
        :return:
            prediction generated by model
        """
        doc = model(text)
        ent_array = []
        for ent in doc.ents:
            start_idx =  text.find(ent.text)
            end_idx = start_idx + len(ent.text)
            entity = [start_idx, end_idx, ent.label_]
            if entity not in ent_array:
                ent_array.append(entity)
        selected_text = text[ent_array[0][0]: ent_array[0][1]] if len(ent_array) > 0 else text
        return selected_text

    def save_model(self, model, model_name, path):
        """
            Save model to path with model_name
        :param model: Type: NerModel, model to be saved
        :param model_name: Type: str, model name
        :param path: Type: str, path to be stored
        :return:
            None
        """
        if not os.path.exists(path):
            os.makedirs(path)
        model.meta["name"] = model_name
        model.to_disk(path)
        print(f"Model is saving to {path}")

    def load_model(self, model_path):
        """
            Load model from model path
        :param model_path: Type: str, path to save model
        :return:
            Ner model
        """
        if not os.path.exists(model_path):
           raise ValueError("model_path doesn't exist")
        print(f"Loading model from {model_path}")
        model = spacy.load(model_path)
        return model


if __name__ == "__main__":
    df_train = pd.read_csv('../inputs/train.csv')
    df_test = pd.read_csv("../inputs/test.csv")

    nermodel = NerModel(output_dir='../outputs')
    train_data = nermodel.generate_data(df_train, sentiment="positive")
    nermodel.train(train_data=train_data, sentiment="positive", n_iter=3)

    train_data = nermodel.generate_data(df_train, sentiment="negative")
    nermodel.train(train_data=train_data, sentiment="negative", n_iter=3)
    output = nermodel.predict(test_df=df_test)
    print(output)






